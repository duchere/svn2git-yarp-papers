\section{Communication}

The basic YARP module is an IPC infrastructure that supports communication across a
network exploiting different protocols. YARP allows interconnecting many modules
seamlessly without subscribing to any specific programming style, language interface, 
or demanding specifications as for instance in CORBA [ref] or DCOM [ref]. That is, YARP 
is a plain library linked to user-level code and as such migration to YARP can be easily
carried out a posteriori. 

Systems such as the already mentioned CORBA, although far more powerful than YARP, require 
adhering to well-defined interface specificiations (nothing bad as such) but consequently 
their link between the general algorithmic code and the communication layer is much 
stricter. 

We have taken a more lightweight approach: any C++ code can use YARP directly just by 
instantiating communication classes. Other programming languages can access YARP as well, 
provided they have means of linking and calling C++ code. We have successfully used YARP 
from within Matlab or L [ref].

Communication channels in YARP can be connected either programmatically or at run-time.
Each communication object, described next, can receive commands from other processes and 
react consequently by activating or removing a specific connection.

The communication abstraction is called a ``port''. The port is an active object managing
multiple connections for a given data type either as input or output (see figure \ref{fig:port}). Each connection has
a state that can be manipulated by certain commands, which manage the connection or obtain
state information from it. Although a port can behave both as input and output, the 
user interface, for convenience, enforces only one direction. An input port can receive 
from multiple connections at different data rates ``speaking'' different protocols
(e.g. TCP, UDP, multicast). An output port can send data to many destinations reading at
different rates on different protocols. Service channels are also temporarily created to
perform the handshaking between ports; in this case the protocol of choice is TCP for
reliability. The use of several different protocol allows to exploit at best their 
characteristics:
\begin{itemize}
	\item TCP: reliable, it can be used to guarantee the reception of a message;
	\item UDP: faster than TCP, used for point to point connections;
	\item multicast: used for creating one to many connections, efficient for distributing
	the same information to many targets;
	\item shared memory: employed for local connections (transparently invoked by the port
	code);
	\item QNet: a fast and synchronous protocol used under the QNX real-time OS.
\end{itemize}

Communication is fully asynchronous and as such messages are not guaranteed to be 
delivered unless special provisions are made. The most natural semantic for YARP ports is
thus that of dealing with recurrent messages, updated and sent often enough, where loosing 
one message does not compromises the integrity of the system. This is tailored at
sensorial data that are generated periodically: e.g. images and sound. YARP is definitely
not an event based system since a single message is not guaranteed to get through. A
typical application is, for example, the acquisition of images, and delivery to many 
machines performing the processing in parallel. Slower processes might simply not
use all the available frames in the stream of data and rather skip some of them.

\begin{figure}
	\centering
		\includegraphics[width=8.5cm]{port.eps}
	\caption{The port internal structure: in practice either input or output connections
	are used for a given instance of a port object.}
	\label{fig:port}
\end{figure}

More recently, at the cost of bidirectional synchronization, a method for guaranteeing
the delivery of messages has been added but this is not the most straightforward and
natural use of ports.

Reading from ports can be blocking, non-blocking (polling), or can happen on a callback.
Writing is normally non-blocking, although it can be made to block depending on the requirements of the channel. In short, once data is available, a reference to a data
buffer (of the same type of the data being received) is returned to the user code. This
remains valid for the user to manipulate it as long as no other calls to the read function
are made. 
On a write, on the other hand, the buffer is passed to the trasmission code which deals
with the details of the communication, while user code can continue execution.

Ports are located on the network by symbolic names which are managed by a name server
(the YARP name server). The name server maps symbolic names (strings) into the triplet 
composed of the IP address, port number, and interface name. This information is all 
what is required to enstablish a socket communication between two endpoints. 
A description of the network topology is stored statically in the name server tables (a
cluster might have multiple and physically separated networks) and used to reply to
registration or connection requests by the clients. The first operation each port must
perform is the registration of its name into the name server. This allows then
communicating to the port. Registration is typically followed by the connection to a peer
of the same data type. When the user is done with the port, it can be stopped,
unregistered, and eventually destroyed.

Ports can deal with any data type. For simple data types (i.e. not containing pointers) 
the port class is already equipped with the appropriate communication code. Complex data
types are dealt by extending the code by specializing the port C++ template for the 
new complex data type and providing the serialization and un-serialization functions. 
This extension is relatively stereotyped and easily realized from client code: that is, 
the library as such does not need to be rebuilt.

Ports were designed with the two-fold goal of reducing the interactions at large between 
the various components of the robot controller and, simultaneously, to allow efficient 
communication between interacting parts of the system. The bottleneck in this approach
would eventually be the available bandwidth on the network. Instead, as long as bandwidth
is available, the addition of new components should minimally interfere with existing 
processes. This is important, since often the actual performance of a robotic controller
depends on the timing of various signals. While this is not strictly guaranteed by the 
YARP infrastructure, the problem is in practice alleviated computationally by allowing 
the inclusion of more processors to the network, and from the communication point of view
by isolating sub-components.

YARP does not contain any means of automatically allocating processes to a cluster of
processors as in some approaches like GRID []. Our apporach is that of leaving this
task to the user to act sensibly and allocate the processes. The rationale is that: i)
special interface hardware is necessarily to be controlled by the appropriate piece of 
software, and ii) in an etherogeneous network of processors, faster processors might 
need to be allocated differently from slower processors. The final behavior is that of 
a sort of ``soft real-time'' parallel computation cluster without the more demanding
requirements of a real-time operating system.

In complex systems, with dozens of processes and hundreds of connections, it might become
unpractical to shut down and restart the whole system every time a module is even slightly 
changed. YARP allowing the run-time connection of channels takes a reasonable approach
here by permitting the disconnection of only those parts of the system that need to be, 
for instance, rebuilt.

Finally, it is important to note that ports are implemented as C++ templates and 
specialized to the type of the data to be transmitted or received. This creates a very 
clean and consistent client interface.

\subsection{YARP interface}
It is perhaps instructive to show a few of the constructs that populate the YARP approach
to communication code. As we mentioned before, the main communication instrument is the 
port. In practice, when coding, ports are always instantiated of a given type as for 
example:

\begin{verbatim}
    YARPInputPortOf<int> in_port
        (YARPInputPort::DEFAULT_BUFFERS);

    in_port.Register ("/my_in_port");
    
\end{verbatim}

\noindent which creates a port apt to receive an integer with the default buffering
provided by the communication layer. The next statement 
instructs the port to register with the name server with the name ``/my\_in\_port''. An 
hypothetical sender should conversely create a port as in the following example:

\begin{verbatim}
    YARPOutputPortOf<int> out_port
        (YARPOutputPort::MANY_OUTPUTS, 
         YARP_TCP);

    out_port.Register ("/my_out_port");

\end{verbatim}

\noindent which is clearly an output port employing the TCP protocol. The protocol type
is determined by the output port since the input port can receive in any of the available
protocols. Also in this case, the port has to register with the name server by calling 
{\em Register()}. As described earlier, the port is a template with the argument of the
template being the type of the data being sent.

The next step is to make the input port wait for data and conversely the output port send
data. The blocking wait is obtained by the following piece of code:

\begin{verbatim}
    if (in_port.Read()) {
        int datum = in_port.Content();
        cout << datum << endl;
		}

\end{verbatim}

\noindent that shows how to read from the port with a blocking {\em Read()} and acquire
the received data through {\em Content()}. The content of the port remains valid until a
subsequent call to {\em Read()} while failing to read does not guarantee the integrity
of the content which should not be accessed. On the sender side we will have something 
like:

\begin{verbatim}
    out_port.Content() = 42;
    out_port.Write ();

\end{verbatim}

\noindent which fills the content by accessing the buffer through {\em Content()} and 
sends it by calling {\em Write()}. If we now connect the two processes (the one receiving
and the other sending) by, for example, using the YARP utility {\em yarp-connect}:

\begin{verbatim}
$-  yarp-connect /my_out_port /my_in_port    
\end{verbatim}

\noindent we obtain the connection of the two ports and the exchange of data. As explained,
the communication code is fairly independent from the remaining code and easily separated
by any other code the user might have developed already, even other communications 
mechanisms. When done with the communication the user can detach the ports using the same
utility (note the exclamative mark before the receiver name):

\begin{verbatim}
$-  yarp-connect /my_out_port !/my_in_port 
\end{verbatim}

The ports are not destroyed by detaching them and in fact can be connected and disconnected
ad lib. When done with the ports instead the user code can call {\em Unregister()} to 
remove the ports from the name server, and finally destroy them by invocation of the C++
destructor (perhaps implicitly when exiting the port scope).

This short example shows all the main features of the port classes including the strong
typization of the communication channels, the independence of the connected processes, and
the use of an external utility to command ports.