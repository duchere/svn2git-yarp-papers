

%% Just temporary
\tableofcontents

\section{Introduction}

%%Hardware defines the environment within which software operates.  

Software development is, in some ways, like natural 
evolution.  Every piece of software has its niche:
the environmental conditions within which it can be
used.  Within this niche it will grow and change and 
perhaps expand to nearby niches.
%%
Some niches are very large (for example, commercial PCs), some are
tiny (a newly developed humanoid).  In this paper, we are concerned
about how robotics researchers can avoid being caught in a tiny
niche, and how to prevent ``genetic isolation'' from setting in,
where software development is slow and cut-off from the mainstream.
We want to find a way to avoid this trip, without sacrificing
the freedom to radically change our hardware, a freedom that
will be crucial in ``bleeding-edge'' research for years to come.

Our motivation comes from the condition of humanoid robotics 
research, but most of this paper is not specific to that field.
%
We think it is relevant to any small research group, either academic or
industrial, who wishes to develop novel robots (as opposed to 
build applications on existing robots).  We want to maximize the 
reach of such research groups.


%Robots with unusual hardware can find themselves initially bereft of
%software, until adaptation occurs.  Therefore robots that take
%advantage of novel hardware may require significant software effort.


%Any given piece of software can operate in a certain set of 
%environments.  Every new robot is a new environment, with some
%overlap with existing ones.  Some software will run there,
%some will not.

In terms of software, robotic platforms can be quite ``genetically
isolated'' from the mainstream population of PCs.  

Research groups that all use a specific robot (Khepera, Pioneer, AIBO,
...) often form a natural software community.  But each alone is 
a small subset of robotics.

Groups developing new robots face obstacles.  There are big barriers
to software collaboration: differences in sensors, actuators, and
bodies; differences in processors, operating systems, libraries,
frameworks, languages, compilers.

Computer science and PCs operate in a world that has been at least
partially commodified; research groups in CS do not have to 
reinvent the operating system for every project they undertake.

Robot software development is like computer software development,
only more so.

Software development for humanoid robots is somewhat of a back-water.
Although it is a topic that excites the public imagination, the
actual resources devoted worldwide are quite low.  The Japanese
government and car manufacturers have invested in some high-profile
projects...


%Humanoid robotics is our passion, but in the grand scheme
%of world-wide software development 


%Big companies built on OSS (e.g. Google)



\begin{figure}
\centerline{
\includegraphics[width=8cm]{fig-nethead}
}
\caption{
%
Basic robot model.  We assume a set of computers, some of which may be
on the robot, some of which may not be.  We assume that the computers
are diverse: they may have different devices, operating systems,
processors, and the programs they run may use different languages,
libraries, etc.  We nevertheless require that threads within processes
on any of these computers be able to communicate easily with each other.
This communication, ideally, should fit well with basic UNIX 
tools and concepts (although we do not assume the operating systems
in use are UNIX-based).
%
%
%
(specific iCub example given later).
%
}
\end{figure}





