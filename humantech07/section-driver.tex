\section{Devices and Drivers}

Code reuse becomes difficult at the level where algorithms 
communicate with the low-level hardware. The OS layer of YARP tries 
to minimize dependencies between algorithms and the hardware for 
which the operating system defines a constant interface (threading, 
memory, network, filesystem). Unfortunately more specific harware 
(motor control boards and framegrabbers are just popular 
examples) requires a more sophisticated mechanism. In these 
cases vendors provide device drivers and a set of API to simplify 
code development. The API comes in the form of a static or dynamic 
library which must be linked in the user code. Unfortunately
APIs vary a lot even within devices that belong to the same family. 
Even worse the API of the same hardware may vary on different 
operating systems or change on future releases of the hardware. User 
code becomes dependent on the particular board for which it was initially 
developed and bound to the decisions and assumptions of the vendor. For 
example venodor A might decide to use integers to represent the position 
of a motor joint, wheras vendor B might decide to use a floating point
variable. Often even similar devices have different ``initialization'' 
procedure. Consider for example a motor control board which has a serial
interface to the host computer; the API of this board will probably require 
that some parameters (port number, baud rate, number of data bits, etc) are 
specified when the device is created. Suppose now that we obtain a more 
recente release of the same board that now has a USB interface. In this 
case the parameters to initialize the board are different and we are forced 
to rewrite all processes that use it (the situation is 
represented in Figure (\ref{fig:devices1})). When possible these (and other) 
differences must be hidden if we want that the same user code can 
effectively interface to the two devices.

\begin{figure}[tbp]
\centerline{
\includegraphics[width=24cm]{fig-devices1.eps}
}
\caption{Example of code dependency. VA-Board is a 
motor control board which interface to the robot through serial port. 
Changes in the board (in the example above the VB-Board has s USB 
interface) are propagated to the user code.}\label{fig:devices1}
\end{figure}

YARP implements the separation between user and device specific code 
in three ways: i) definition of interfaces for families of devices ii) 
localization and separation of device initialization and creation 
ii) creation of network wrappers and separation between devices and 
communication. 

\subsection{Device Interfaces}

An interface to a YARP device is the specification of the functionalities
it provides. In practice in C++ an interface is a virtual base class, whose 
member functions define the ensamble of the functionalities a device must 
implement to be able to provide that interface. The implementation of a 
YARP device consists in a ``wrapper'' class which implements all 
methods specified by the interface. A single device can of course expose 
more than a single interface (in C++ this is implemented through multiple
inheritance). All details specific of the hardware 
(vendor's API and library) are handled here and are hidden by its interfaces. 
The idea is that changes in the hardware are catched by the wrapper class 
and never propagated to the user code. As a result, if interfaces are 
well designed, the impact on the code due to hardware change is minimized. 

Another aspect that we have pointed out above, is the fact that 
initialization parameters may introduce annoying dependencies in the user 
code. To solve this we have defined a common interface to all devices (the 
\emph{DeviceDriver} interface) which normalizes how devices are initialized
and un-initialized, and, more importantly, how initialization parameters 
are passed to them. In particular this interface defines two methods:

\begin{verbatim}
  virtual bool open(yarp::os::Searchable& config)=0;
\end{verbatim}

and

\begin{verbatim}
  virtual bool close()=0;
\end{verbatim}

This \emph{open} method initializes the device. Initialization parameters 
are passed to the function as a list of key-value entries 
(a \emph{Searchable} object). A \emph{Searchable} can contain all 
possible parameters devices might require for initialization. Initialization 
parameters for devices 
are stored in ``.ini'' files (again in the form of a list of key-value 
entries). A process that wants to open a device reads 
the file and transfers its content into a \emph{Searchable} object. This 
object is passed to the device through the \emph{open} function. 
It is worth stressing that up to now this procedure is totally device 
independent, because the parameters are just copied and not interpreted 
by the process. It is only in the implementation of the \emph{open} method 
(in the wrapper class of the device) where the \emph{Searchable} object 
is parsed to extract the parameters that will be used to inizialize the 
device.

The \emph{close} method performs all the operations required to shut down 
the device properly and release all the resources it was using. No
parameters are required by this function.



\begin{figure}[tbp]
\centerline{
\includegraphics[width=24cm]{fig-devices2.eps}
}
\caption{Interfaces allow code reuse. VA-Board and VB-Boards (see 
Figure (\ref{fig:devices1})) now implement
the same interfaces (through their respective wrapper classes). The user 
code access the hardware through these interfaces and is not aware of 
the details of how the methods are actually implemented. The different 
initialization parameters are listed in configuration files and are thus 
separated from the code.}\label{fig:devices2}
\end{figure}

Interfaces to broad families of devices have been defined in YARP. For 
example this is a partial list of the interfaces that have been defined 
for devices belonging to the family of frame grabbers:

\begin{itemize}

\item \emph{IFrameGrabberRgb}, which defines the interface to devices 
which generate a stream of color images. Methods in this interface 
provide access to the most recent frame acquired by the device, and 
information about its size (number of columns and rows).

\item \emph{IFrameGrabberControls}, specifies a set of functionalities 
to control a typical framegrabber device. Methods of this interface 
allows controlling the parameters of acquisition of the device, like 
shutter speed, brightness and gain.

\end{itemize}

Interfaces to motor control devices are more difficult to define. Control 
boards designed for industrial applications have often a quite stadard 
interface which provides a PID control algorithm and position or velocity 
control modes. Things become more complicated when we consider also 
programmable devices that can implement virtually an infinite type of 
functionalities and control algorithms. 
For this reason interface to control boards has been defined on the basis 
of the control paradigm they implement. Accordingly, YARP defines:

\begin{itemize}

\item \emph{IEncoder}: group all methods providing access to the motor 
encoders, like methods for reading the current position of velocity of 
each axis

\item \emph{IPositionControl}: methods to control motion of each axis 
by specifying its position (usually referred to as ``position control'')

\item \emph{IVelocityControl}: methods to contorl motion of each axis 
by specifying its velocity (usually referred to as ``velocity control'')

\item \emph{ITorqueControl}: defiens methods to control the amount of 
force/torque exerted by each axis (usually referred to as ``torque or 
force control'').

\end{itemize}

These last interfaces are indipendent of the particular algorithm the 
control board implements to realize the corresponding functionality. 
These details are delegated to specific interfaces. For example 
\emph{IPidControl} includes methods to interface to a PID controller, 
like for example read or set the values of the gains.

As an example Figure (\ref{fig:devices2})) shows how 
YARP interfaces allows code reuse in cases two different motor boards 
are used to control the same piece of hardware (the problem described 
in Figure (\ref{fig:devices1}).

\subsection{A factory of devices}

We have seen that forcing access devices only through 
interface achieve a good level of separation between vendor/device 
specific APIs and user level code. Interfaces alone, however, do not 
guarantee a complete level of separation. In practice users must still 
specify the type of device they want to create. Care must be taken to 
avoid that this introduces device dependent code. A common software 
engineering practice is to \emph{localize object creation} so to 
minimize the amount of code that is responsible for object creation 
and initialization. 
We have seen that in YARP part of this is realized by the 
\emph{DeviceDriver} interface, which forces all initialization procedures 
to be performed inside the \emph{open} method. Device creation is instead 
delegated to a \emph{factory}. The \emph{factory} contains a list of 
all devices available in YARP and the corresponding functions to call 
to create them. It receives from a list of initialization parameters, 
creates the device, and initializes it 
through the \emph{DeviceDriver} interface. If the process is successfull 
a valid pointer to the device is returned. This pointer is the only 
``access point'' to the device and its interfaces. Other interfaces can 
be obtained by casting this pointer to the appropriate virtual class 
(in C++ this can be safely done through dynamic cast). 

The whole process of creation, initialization and interface access is 
managed by the \emph{PolyDriver} object. The user has only direct access 
to the \emph{PolyDriver}, to which he asks the creation of a particolar 
device, through the \emph{PolyDriver::open())} method. This request is 
forwarded to the \emph{factory} which creats an instance of the particular 
device driver the user wants to use. Device drivers are uniquely identified 
through a symbolic name; the \emph{factory} searches the list of device 
for an entry whose name matches the one that is requested and, if the match 
is found, it calls the appropriate constructor. If the driver is successfully 
created the \emph{factory} returns a valid pointer which is stored inside 
the \emph{PolyDriver}. The lifecycle of the device is managed by the 
\emph{PolyDriver}; the user can access only to copies of this pointer 
thourgh calls to the \emph{PolyDriver::view()} method, which performs 
a dynamic cast of the internal pointer to the device driver to expose 
the requested interface before returning it (this mechniam is sketched 
in Figure (\ref{fig:devices4}) \emph{NOTE: not sure this picture is 
really needed, consider removing it}).

\begin{figure}[tbp]
\centerline{
\includegraphics[width=20cm]{fig-devices4.eps}
}
\caption{Device creation and initialization. Creation of 
devices in YARP in delegated to a \emph{factory} object. Users 
access devices through instances of the \emph{PolyDriver}. The 
Figure describes the following situation. Process1 controls a robotic
head and needs to access to the robot framegrabber (whose symbolic name 
is ``dragonfly'') and to the control board connected to the motors of 
the head (``mboardA''). Process1 creates \emph{PolyDriver} and opens 
the device; the symbolic name of the device is passed as a parameter
of the \emph{open} function, together with initialization parameters 
read from a .ini file. The \emph{PolyDriver} hands over these parameters 
to the \emph{factory} which creates an instance of the device and returns
it to the \emph{PolyDriver}. Subsequent calls to the driver are entirely 
handled by the \emph{PolyDriver} itself. Process1 calls \emph{view} to 
acquires the appropriate interfaces to the device. A similar procedure 
is performed by the same process or other processes (Process 2 in Figure) 
to create instances of different devices.}\label{fig:devices4}
\end{figure}

\subsection{An example: accessing a motor control board}

For example suppose we want to use the \emph{test\_motor} device. In 
YARP this is a fake device which simulates a control board controlling 
4 axes. This device supports the \emph{IPositionControl} and 
\emph{IVelocity} interfaces. To begin with, we first create an 
instance of the \emph{PolyDriver}. The actual device is create by 
calling the \emph{PolyDriver::open()} method specifying the symbolic 
name of the device (e.g. \emph{test\_motor}):

\begin{verbatim}
  PolyDriver device;
  device.open(\"test\_motor\");
\end{verbatim}

Now we can ask interfaces to \emph{test\_motor} by calling the 
\emph{PolyDriver::view()}method:

\begin{verbatim}
  IPositionControl *ipos=0;
  device.view(ipos);

  IVelocityControl *ivel=0;
  device.view(ivel);
\end{verbatim}

Checking if ivel and ipos are not null assures that \emph{test\_motor} 
really supports the respective interfaces.

We can now call methods of the \emph{IPositionControl} interface to control 
joint $0$ to move to the angular position of $40deg$, with the velocity 
of $5\frac{deg}{s}$ and acceleration of $100\frac{deg}{s^2}$:

\begin{verbatim}
ipos->setRefAcceleration(0, 100);
ipos->setRefSpeed(0, 5)
ipos->positionMove(0, 40);
\end{verbatim}

Or use the \emph{IVelocity} interface to servo joint 1 at the velocity 
of $5\frac{deg}{s}$ with the acceleration of $100\frac{deg}{s^2}$:

\begin{verbatim}
ivel->setRefAcceleration(1,100);
ivel->velocityMove(1, 5);
\end{verbatim}

\subsection{Device Remotization: Binary Interfaces}

A final level of separation is achieved by supporting device remotization. 
This feature is important because flexibility imposes 
that processes are written so that they can be easily moved across 
distinct machines, if needed. Knowledge of whether a process is accessing 
a given device locally or remotely would clearly limit this flexibility, 
because it would force modification in the code of the process itself. 
Remotization also facilitate portability across different platforms, as 
it naturally defines a ``binary'' interface that can 
be used to make resources available on one platform to processes compiled 
and running on a different one. This decouple the compilation, build 
environment, libraries, operating system and language dependencies of 
hardware and user software.

The remotization mechanism relies on the communication layer (see \emph{add 
reference to port section} and on two \emph{Network Wrappers} one acting 
as a \emph{Server} and the other acting as a \emph{Client}. 
Both \emph{Network Wrappers} are devices implementing the very same set 
of interfaces as the device they wrap. Both devices act proxies and talk 
to each other using a predefined protocol, which involves one or more 
YARP Ports configured for RPC or streaming (see \ref{fig:devices3})

The \emph{Server Wrapper} creates an instance of the wrapped device and 
forwards requests from the incoming connections to the device by calling 
its interfaces. If the request involves a reply this is sent back to the 
calling port so that it is received by the remote client. The mechanism 
used by the \emph{Server Wrapper} to access the local device is the same 
we have described for the user code; as 
such the \emph{Server Wrapper} is a total independent entity that can be 
reused for all devices implementing the same interface(s). 

The process at the other side of the communication creates the 
\emph{Client Wrapper}. The latter exports exactly the same interfaces as the 
device driver it wraps so the process is not aware that it is not talking to 
a real device. The job of the \emph{Client Wrapper} is to convert calls from 
the user code in packets of bytes and send them to the other end of the 
communication, and, in case a reply is expected, waits for data and dispatch 
it to the calling process. The responsibility of the proxies among the other 
things is to perform the marshalling and de-marshalling of the information 
so that it is correctly interpreted by the distinct platforms (this is 
required for systems in which data is represented with different standards).

\begin{figure}[tbp]
\centerline{
\includegraphics[width=24cm]{fig-devices3.eps}
}
\caption{Network wrappers allow device remotization. A generic Network 
wrapper exports the YARP interfaces so that they can be accessed remotely 
by another machine through an RPC mechanism. At the other side of the 
communication the client wrapper exports the network interface back 
to the YARP interfaces from which the device is transparently accessed 
by the client code. The only difference between a local device and a 
remote one is in term of performances (the time it takes to execute 
a given function).
}\label{fig:devices3}
\end{figure}

Orphan text:

The goal of YARP is to support humanoid robotics, in which a broad 
variety of hardware is often employed. In YARP we try to facilitate code 
exchange between researchers, especially when this speeds up the time 
it takes to develop a platform and use it for research. In this sense 
device-level software development is a very time consuming and tedious 
task, so the possibility to share code in this context is extremely 
profitable. YARP devices consists in a set of \emph{wrapper classes}, 
which usually link vendor's libraries.... 

\begin{itemize}

\item Summarize argument that, long term, free software approach 
is better for supporting devices especially with smaller user
bases, obsolescence.


\item Driver access in C/C++ with minimal bureaucracy -- no
entanglement with communication/middleware.  When operating
on a single machine, if the user wishes, operation without
transport or marshalling/demarshalling should be possible, ideally
direct C/C++ calls.

\item Ideally, drivers would be expressed in a form that
can be ``ripped out'' of any library or framework in use
with minimal hassle.

\item Similarly, a communication/middleware mechanism that is 
not tied up with the notion of drivers.

\item A communication/middleware mechanism that is transport
neutral, only depending on broad outline of services.


\end{itemize}




\subsection{Separation of concerns}

There are three separate concerns related to devices in YARP:

Implementing specific drivers for particular devices 

Defining interfaces for device families 

Implementing network wrappers for interfaces

Basic idea: if you view your devices through well thought out
interfaces, the impact of device change can be minimized.






\subsection{Sticky devices}

Consider the following scenarios:

\begin{itemize}

\item A user acquires a piece of hardware they want to use.  The
hardware is very new.  It is bundled with a binary library and a
skimpy example program that is the only way currently known to access
that hardware.  Use of the library is quite restricted; it may be
specific to a particular operating system version or even development
environment.

\item A user acquires many such devices, and wants to use them
all at the same time.

\end{itemize}

Let us call devices which can only be accessed using vendor supplied
material ``sticky devices'' because they tend to make the particular
set of assumptions made by the vendor stick to the user's code.
Dealing with several sticky devices at once becomes a nightmare.
Worse still, any and all of those assumptions could change on the
next release of the hardware~-- this is particularly likely if the 
hardware is very new.

A logical step in such a situation is to wrap the functionality
supplied by the vendor in a facade, so that at least source code
dependencies can be reduced.  But at a more basic level,
compilation and linking of application that accesses two or more
sticky devices can be very involved.  An option that YARP makes
available is for wrappers around the devices to be made individually,
compiled and built separately, and then used across the network.
When performance requirements permit this solution it is an
effective mechanism for quarantining the sticky devices.

We split the process of creating an interface to a device into two
parts: the ``thin wrapper'', and the ``network wrapper''.  

Writing the thin wrapper means creating a C++ API to the device
that follows a simple regular structure defined by YARP
(examples for interfacing with devices are usually written in C/C++).
If there are similarities between this device and others,
those similarities can be captures at this point by 
shared interfaces with different implementations.
Once the thin wrapper is written, user code that accesses
the device through that wrapper is less affected by its ``stickiness''
because:

\begin{itemize}

\item To the extent that user code uses interfaces shared by other
devices, another device can be substituted later without change to
that part.  This could also include future versions of the same family
of hardware.

\item The network wrapper, when written, will allow the thin wrapper
interface to be used via the network.  This decouples the compilation,
build environment, libraries, operating system, and language
dependencies of the device software and the user software.

\end{itemize}

Wrappers are written for families of interfaces, and so in as much
as one device is similar to existing devices, the network 
wrapper may come for free.

Why is it important to make devices easy to write?

\begin{itemize}

\item New hardware appears all the time, so the odds of a particular
user being one of the first people interested in a particular device are
non-negligible.  We are particularly interested in supporting humanoid
robotics, where today's hardware is very lacking and we are guaranteed
to be dealing with novel hardware for the forseeable future.

\item Vendors may bundle hardware and software, and not permit
redistribution of their software.  In practice, this can mean that
work done to wrap a device by one group may not end up in a public
repository, and so not reach other groups.  Licensing issues can push
the amount of effort required above what a group is willing to
casually contribute.  So some reinventing of the wheel is inevitable.
This seems to be particularly the case on the Microsoft Windows
platform, where the pool of free and open software available to build
on is smaller and much more poorly packaged.

\item There are several software architectures in existence for
various overlapping robotics communities.  If someone has adapted
a device to one of these architectures, it is still not trivial
to use it in another.  YARP is trying to be a good citizen by
reducing how much the core device code depends on YARP itself,
making it in principle easier to reuse.


\end{itemize}



\subsection{The many-architecture problem}

YARP is but one software architecture of many.  For example, in the
world of mobile robotics, the Player/Stage project is widely used.

We should be careful of assuming that the interface the end-user will
want to the device is a YARP interface.

The thin wrapper is a first step that attempts to reshape a
device from a vendor into something a little bit more organized.

The trajectory imagined for device creation:

\begin{itemize}

\item User works with whatever code they can get -- vendor
supplied, from another project, etc.

\item User wraps a simple class around the functionality,
meeting YARP's simple specification for devices.  At this
point, the reward they get is that device configuration
can be easily made external to the code.  This is often
useful when starting up a device for different purposes
(normal, testing, different experimental parameters etc).

\end{itemize}


\subsection{Driver}

We use the term ``Driver'' to refer to software interface the end-user
has to a hardware device.  The software components involved in
implementing the driver can be considered to be part of the device if
we wish.  We can consider the process of taking a ``sticky device''
and placing in a wrapper as a process of transforming the device such
that drivers are easier to build.


