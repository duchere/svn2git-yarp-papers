

\section{Ports}

Data source knows nothing about identity of modules that monitor it.
(picture).

We follow the Observer design pattern. 

Special ``Port'' objects deliver data to:

Any number of observers (other ``Port''s) ...

... in any number of processes ...

... distributed across any number of computers/OSes ...

using any of several underlying communication protocols with different
technical advantages, streaming or RPC

This is called the YARP Network

Connections can use different protocols

Ports belong to processes

Processes can be on different machines/OS

(picture)

\section{Network example}

RobotCub picture, with gigabit network.

\section{Why?}

We've separated out most of the plumbing

We get to change it dynamically (handy)

More importantly, we have better modularity

Programs can be moved around as load and OS/device/library
 dependencies dictate

Fundamental protocol for communication can be changed without 
affecting programs

Better chance that your code can be used by others (even just within 
your group)


\section{YARP Devices}

There are three separate concerns related to devices in YARP:

Implementing specific drivers for particular devices 

Defining interfaces for device families 

Implementing network wrappers for interfaces

Basic idea: if you view your devices through well thought out
interfaces, the impact of device change can be minimized.


\subsection{A light touch}

New devices come out all the time -- needs to be easy to connect them
to existing code

YARP needs a minimal ``wrapper'' class to match vendor-supplied
library with relevant interfaces that capture common capabilities

YARP encourages separating configuration from source code -- separating
the ``plumbing''

Devices and communications remain distinct concerns

(pictures)


\subsection{Why?}

Allows collaboration between groups whose robots have different devices

Makes device changes less painful

Devices and communications are orthogonal features

Can switch from remote use of device to local use and vice versa without pain

Local use can be very efficient, just an extra virtual method call

